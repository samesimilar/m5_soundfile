#N canvas 198 62 1237 800 12;
#X declare -lib m5_soundfile;
#X obj 32 37 declare -lib m5_soundfile;
#X msg 67 366 mark;
#X obj 475 221 dac~, f 6;
#X msg 258 46 time playQuantizedTime;
#X obj 252 21 loadbang;
#X obj 690 55 bng 19 250 50 0 empty empty empty 0 -10 0 12 #fcfcfc #000000 #000000;
#X obj 431 68 bng 19 250 50 0 empty empty empty 0 -10 0 12 #fcfcfc #000000 #000000;
#X msg 518 119 stop never;
#X obj 436 92 t b b b;
#X obj 578 223 bng 19 250 50 0 empty empty empty 0 -10 0 12 #fcfcfc #000000 #000000;
#X obj 573 305 print file length;
#X msg 693 124 start \$1 \$2 \$3;
#X msg 914 129 stop \$1 \$2 \$3;
#X text 127 366 mark current time as t=0;
#X text 50 441 All objects that refer to 'playQuantizedTime' ... defined by this Time Anchor object ... will use the same 'clock'.;
#X text 212 92 For m5readsf~ \, the time anchor is assigned by sending a 'time' message. (If a time anchor is not assigned \, then m5readsf uses a private internal timer \, but it's not sync'd with other objects.), f 21;
#X obj 56 403 m5_ftc_anchor playQuantizedTime;
#X obj 660 94 m5_ftc_cycles playQuantizedTime;
#X obj 913 94 m5_ftc_cycles playQuantizedTime;
#X obj 520 190 m5_readsf~ 1, f 19;
#X obj 589 272 s fileLength;
#X obj 788 65 r fileLength;
#X obj 1151 61 r fileLength;
#X msg 903 63 2;
#X obj 23 360 bng 19 250 50 0 empty empty empty 0 -10 0 12 #fcfcfc #000000 #000000;
#X obj 67 495 print ftc current;
#X text 459 67 1) init;
#X text 668 5 2) do start at time of next loop point as if it had been looping from t=0, f 32;
#X text 931 65 3) stop after 2nd loop after click;
#X text 424 117 comment;
#X msg 521 155 looplength self;
#X msg 520 138 open t1.wav;
#X text 911 332 Sending start or stop \, with these timecodes \, to m5_readsf~ will start/stop at the specified sample frame., f 24;
#X obj 939 174 print stop time;
#X obj 738 201 print start time;
#N canvas 662 362 553 381 counting_example 1;
#X obj 122 118 m5_ftc_cycles;
#X obj 124 182 print min loops needed;
#X msg 186 77 1 0 50000;
#X msg 28 42 count 1 0 25000;
#X msg 29 69 count 1 0 50001;
#X msg 26 99 count 1 1 0;
#X obj 186 47 loadbang;
#X obj 124 152 expr ceil($f1);
#X obj 119 269 m5_ftc_mult;
#X obj 118 297 print total time needed;
#X obj 95 245 list;
#X obj 118 213 t b f, f 11;
#X text 228 236 e.g. multiply loop_length * minimum number of loops to get total time, f 26;
#X text 296 84 send 'count' plus an FTC value to output the number of loops with loop_length (right) needed to contain the given duration (left), f 31;
#X connect 0 0 7 0;
#X connect 2 0 0 1;
#X connect 2 0 10 1;
#X connect 3 0 0 0;
#X connect 4 0 0 0;
#X connect 5 0 0 0;
#X connect 6 0 2 0;
#X connect 7 0 1 0;
#X connect 7 0 11 0;
#X connect 8 0 9 0;
#X connect 10 0 8 0;
#X connect 11 0 10 0;
#X connect 11 1 8 1;
#X restore 599 372 pd counting_example;
#X text 913 220 On BANG (left inlet) m5_ftc_cycles outputs the time code of the beginning of the next loop \, determined by the length sent to the right inlet... relative to the time marked by the named m5timeAnchor, f 37;
#X connect 1 0 16 0;
#X connect 3 0 19 0;
#X connect 4 0 3 0;
#X connect 5 0 17 0;
#X connect 6 0 8 0;
#X connect 7 0 19 0;
#X connect 8 0 30 0;
#X connect 8 1 7 0;
#X connect 8 2 31 0;
#X connect 11 0 19 0;
#X connect 12 0 19 0;
#X connect 16 0 25 0;
#X connect 17 0 11 0;
#X connect 17 0 34 0;
#X connect 18 0 12 0;
#X connect 18 0 33 0;
#X connect 19 0 2 0;
#X connect 19 0 2 1;
#X connect 19 1 9 0;
#X connect 19 2 20 0;
#X connect 19 2 10 0;
#X connect 21 0 17 1;
#X connect 22 0 18 1;
#X connect 23 0 18 0;
#X connect 24 0 16 0;
#X connect 30 0 19 0;
#X connect 31 0 19 0;
#X connect 31 0 7 0;
